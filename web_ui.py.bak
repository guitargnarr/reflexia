#!/usr/bin/env python3
"""
Web UI for DeepSeek LLM implementation
"""
import os
import logging
import time
from pathlib import Path
from flask import Flask, render_template, request, jsonify, send_from_directory
from flask_socketio import SocketIO, emit
import requests

logger = logging.getLogger("deepseek-tools.web_ui")

class WebUI:
    """Web UI for DeepSeek LLM implementation"""
    
    def __init__(self, config, model_manager, memory_manager, prompt_manager, rag_manager=None):
        """Initialize the Web UI
        
        Args:
            config: Configuration object
            model_manager: ModelManager instance
            memory_manager: MemoryManager instance
            prompt_manager: PromptManager instance
            rag_manager: RAGManager instance (optional)
        """
        self.config = config
        self.model_manager = model_manager
        self.memory_manager = memory_manager
        self.prompt_manager = prompt_manager
        self.rag_manager = rag_manager
        
        # Set host and port right at initialization
        self.host = self.config.get("web_ui", "host", default="127.0.0.1")
        self.port = self.config.get("web_ui", "port", default=8000)
        
        # Create Flask app
        self.app = Flask(__name__, 
                     template_folder="web_ui/templates",
                     static_folder="web_ui/static")
        
        # Create SocketIO instance
        self.socketio = SocketIO(self.app, cors_allowed_origins="*")
        
        # Setup routes
        self._setup_routes()
        
        # Ensure Socket.IO JS is available
        self._ensure_socket_io_js()
        
        logger.info("Web UI initialized")
    
    def _setup_routes(self):
        """Setup Flask routes"""
        
        @self.app.route("/")
        def index():
            return render_template("index.html")
        
        @self.app.route("/api/documents", methods=["GET"])
        def get_documents():
            if self.rag_manager:
                docs = self.rag_manager.list_documents()
                return jsonify({"documents": docs})
            return jsonify({"documents": []})
        
        @self.app.route("/api/documents/<doc_id>", methods=["DELETE"])
        def delete_document(doc_id):
            if self.rag_manager:
                success = self.rag_manager.delete_document(doc_id)
                if success:
                    return jsonify({"success": True})
                return jsonify({"success": False, "error": "Document not found"})
            return jsonify({"success": False, "error": "RAG not available"})
        
        @self.app.route("/api/upload", methods=["POST"])
        def upload_file():
            if not self.rag_manager:
                return jsonify({"success": False, "error": "RAG not available"})
            
            if "file" not in request.files:
                return jsonify({"success": False, "error": "No file part"})
            
            file = request.files["file"]
            if file.filename == "":
                return jsonify({"success": False, "error": "No selected file"})
            
            try:
                # Save file temporarily
                temp_path = Path("temp") / file.filename
                os.makedirs("temp", exist_ok=True)
                file.save(temp_path)
                
                # Load into RAG
                success = self.rag_manager.load_file(temp_path)
                
                # Clean up
                os.remove(temp_path)
                
                if success:
                    return jsonify({"success": True, "filename": file.filename})
                else:
                    return jsonify({"success": False, "error": "Failed to process file"})
            except Exception as e:
                logger.error(f"Error uploading file: {e}")
                return jsonify({"success": False, "error": str(e)})
        
        @self.socketio.on("connect")
        def handle_connect():
            logger.info(f"Client connected: {request.sid}")
        
        @self.socketio.on("disconnect")
        def handle_disconnect():
            logger.info(f"Client disconnected: {request.sid}")
        
        @self.socketio.on("get_initial_data")
        def handle_get_initial_data():
            # Send templates
            templates = self.prompt_manager.list_templates()
            emit("templates", {"templates": templates})
            
            # Send system prompt
            emit("system_prompt", {"prompt": self.prompt_manager.get_system_prompt()})
            
            # Send memory usage
            memory_stats = self.memory_manager.get_memory_stats()
            emit("memory_update", {
                "percent": memory_stats["percent"],
                "used_gb": memory_stats["used"] / (1024 * 1024 * 1024),
                "critical": memory_stats["critical"]
            })
            
            # Send documents if RAG is available
            if self.rag_manager:
                docs = self.rag_manager.list_documents()
                emit("documents", {"documents": docs})
        
        @self.socketio.on("user_message")
        def handle_message(data):
            # Process message in a background thread to not block
            import threading
            thread = threading.Thread(
                target=self._process_message,
                args=(data["message"], data.get("use_rag", False), 
                     data.get("template", "default"), 
                     data.get("temperature", 0.7), 
                     data.get("top_p", 0.9),
                     request.sid)
            )
            thread.daemon = True
            thread.start()
        
        @self.socketio.on("clear_chat")
        def handle_clear_chat():
            logger.info("Clearing chat history")
        
        @self.socketio.on("update_system_prompt")
        def handle_update_system_prompt(data):
            prompt = data.get("prompt", "")
            if prompt:
                self.prompt_manager.set_system_prompt(prompt)
                logger.info("System prompt updated")
                emit("system_prompt", {"prompt": prompt})
    
    def _process_message(self, message, use_rag, template, temperature, top_p, sid):
        """Process a user message in a background thread"""
        try:
            # Send typing indicator
            self.socketio.emit("status", {
                "status": "thinking",
                "message": "Generating response..."
            }, to=sid)
            
            # Format the prompt using the specified template
            formatted_prompt = self.prompt_manager.format_prompt(message, template_name=template)
            
            # Start time measurement
            start_time = time.time()
            
            # Memory stats before generation
            before_memory = self.memory_manager.get_memory_stats()
            
            # Generate response
            if use_rag and self.rag_manager:
                # Generate RAG response
                result = self.rag_manager.generate_rag_response(
                    message,
                    system_prompt=self.prompt_manager.get_system_prompt()
                )
                response = result["response"]
                sources = result.get("sources", [])
                
                # Send the response with sources
                self.socketio.emit("message", {
                    "message": response,
                    "sources": sources,
                    "processing_time": time.time() - start_time
                }, to=sid)
            else:
                # Generate standard response
                response = self.model_manager.generate_response(
                    formatted_prompt,
                    system_prompt=self.prompt_manager.get_system_prompt(),
                    temperature=temperature,
                    top_p=top_p
                )
                
                # Send the response
                self.socketio.emit("message", {
                    "message": response,
                    "processing_time": time.time() - start_time
                }, to=sid)
            
            # Memory stats after generation
            after_memory = self.memory_manager.get_memory_stats()
            memory_impact = after_memory["percent"] - before_memory["percent"]
            
            # Send detailed memory stats
            self.socketio.emit("memory_update", {
                "percent": after_memory["percent"],
                "used_gb": after_memory["used"] / (1024 * 1024 * 1024),
                "impact": memory_impact,
                "critical": after_memory["critical"]
            }, to=sid)
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            self.socketio.emit("message", {
                "message": f"Error generating response: {str(e)}",
                "error": True
            }, to=sid)
    
    def _ensure_socket_io_js(self):
        """Ensure Socket.IO JavaScript file is available"""
        socket_io_js_path = Path("web_ui/static/socket.io.js")
        if not socket_io_js_path.exists():
            os.makedirs(socket_io_js_path.parent, exist_ok=True)
            try:
                response = requests.get("https://cdn.socket.io/4.5.4/socket.io.min.js")
                with open(socket_io_js_path, "wb") as f:
                    f.write(response.content)
                logger.info(f"Downloaded socket.io.js to {socket_io_js_path}")
            except Exception as e:
                logger.error(f"Error downloading socket.io.js: {e}")
    
        def start(self, debug=False, threaded=False):
        # Set host and port
        self.host = self.config.get('web_ui', 'host', default='127.0.0.1')
        self.port = self.config.get('web_ui', 'port', default=8000)
        """Start the web UI server
        
        Args:
            debug: Enable debug mode
            threaded: Run in a separate thread
            
        Returns:
            bool: Success status
        """
        # Set host and port
        self.host = self.config.get('web_ui', 'host', default='127.0.0.1')
        self.port = self.config.get('web_ui', 'port', default=8000)
        
        logger.info(f"Starting Web UI on {self.host}:{self.port}")
        print(f"Web UI started at http://{self.host}:{self.port}")
        print("Press Ctrl+C to stop")
        
        if threaded:
            import threading
            server_thread = threading.Thread(
        self.socketio.run(self.app, host=self.host, port=self.port, debug=debug, allow_unsafe_werkzeug=True)
                args=(self.app,),
                kwargs={'host': self.host, 'port': self.port, 'debug': debug, 'allow_unsafe_werkzeug': True}
            )
            server_thread.daemon = True
            server_thread.start()
            return True
        else:
            try:
        self.socketio.run(self.app, host=self.host, port=self.port, debug=debug, allow_unsafe_werkzeug=True)
                return True
            except Exception as e:
                logger.error(f"Error running web UI: {e}")
                return False